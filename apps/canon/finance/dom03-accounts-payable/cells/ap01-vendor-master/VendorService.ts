/**
 * Vendor Service
 * 
 * AP-01 Vendor Master Cell - Vendor creation and lifecycle management.
 * 
 * Responsibilities:
 * - Create new vendors (draft status)
 * - Update vendors (draft only)
 * - Submit vendors for approval
 * - Validate vendor data
 * - Emit transactional audit events
 */

import type {
  VendorRepositoryPort,
  Vendor,
  CreateVendorInput as RepoCreateInput,
  UpdateVendorInput as RepoUpdateInput,
  TransactionContext,
  AuditPort,
  AuditEvent,
} from '@aibos/kernel-core';
import type { ActorContext } from '@aibos/canon-governance';
import { VendorStateMachine } from './VendorStateMachine';
import {
  VendorNotFoundError,
  VendorNotInDraftError,
  DuplicateVendorCodeError,
  DuplicateTaxIdError,
  InvalidVendorStatusError,
} from './errors';

// ============================================================================
// 1. TYPES
// ============================================================================

export interface CreateVendorInput {
  legalName: string;
  displayName?: string;
  taxId?: string;
  registrationNumber?: string;
  country: string; // ISO 3166-1 alpha-3
  currencyPreference: string; // ISO 4217
  vendorCategory?: string;
  riskLevel?: 'LOW' | 'MEDIUM' | 'HIGH';
  defaultPaymentTerms?: number;
}

export interface UpdateVendorInput {
  legalName?: string;
  displayName?: string;
  taxId?: string;
  registrationNumber?: string;
  country?: string;
  currencyPreference?: string;
  vendorCategory?: string;
  riskLevel?: 'LOW' | 'MEDIUM' | 'HIGH';
  defaultPaymentTerms?: number;
}

// ============================================================================
// 2. VALIDATION
// ============================================================================

// Valid ISO 3166-1 alpha-3 country codes (common ones)
const VALID_COUNTRIES: Set<string> = new Set([
  'USA', 'GBR', 'CAN', 'AUS', 'DEU', 'FRA', 'JPN', 'CHN',
  'IND', 'SGP', 'MYS', 'THA', 'IDN', 'PHL', 'VNM', 'KOR',
]);

// Valid ISO 4217 currency codes
const VALID_CURRENCIES: Set<string> = new Set([
  'USD', 'EUR', 'GBP', 'JPY', 'CHF', 'CAD', 'AUD', 'NZD',
  'HKD', 'SGD', 'SEK', 'NOK', 'DKK', 'CNY', 'INR', 'BRL',
  'MXN', 'ZAR', 'KRW', 'THB', 'MYR', 'PHP', 'IDR', 'VND',
]);

function validateCountry(country: string): void {
  if (!VALID_COUNTRIES.has(country)) {
    // Allow any 3-letter code, but warn if not in common list
    if (country.length !== 3) {
      throw new Error(`Invalid country code: ${country}. Must be ISO 3166-1 alpha-3 (3 letters)`);
    }
  }
}

function validateCurrency(currency: string): void {
  if (!VALID_CURRENCIES.has(currency)) {
    if (currency.length !== 3) {
      throw new Error(`Invalid currency code: ${currency}. Must be ISO 4217 (3 letters)`);
    }
  }
}

function validateLegalName(legalName: string): void {
  if (!legalName || legalName.trim().length < 2) {
    throw new Error('Legal name must be at least 2 characters');
  }
}

// ============================================================================
// 3. SERVICE
// ============================================================================

/**
 * VendorService - Creates and manages vendor lifecycle
 */
export class VendorService {
  constructor(
    private vendorRepo: VendorRepositoryPort,
    private auditPort: AuditPort
  ) { }

  /**
   * Create a new vendor
   * 
   * @param input - Vendor creation data
   * @param actor - Who is creating the vendor
   * @returns Created vendor
   */
  async create(
    input: CreateVendorInput,
    actor: ActorContext
  ): Promise<Vendor> {
    // 1. Validate input
    validateLegalName(input.legalName);
    validateCountry(input.country);
    validateCurrency(input.currencyPreference);

    // 2. Begin transaction (vendor code generated by database function)
    return this.vendorRepo.withTransaction(async (txContext) => {
      // 3. Check for duplicate tax ID (if provided)
      // Note: Database constraint will enforce uniqueness
      // We could add a findByTaxId method if needed for better error messages

      // 4. Create vendor (state: draft, vendor_code generated by DB function)
      const repoInput: RepoCreateInput = {
        tenantId: actor.tenantId,
        legalName: input.legalName,
        displayName: input.displayName,
        taxId: input.taxId,
        registrationNumber: input.registrationNumber,
        country: input.country,
        currencyPreference: input.currencyPreference,
        vendorCategory: input.vendorCategory,
        riskLevel: input.riskLevel || 'LOW',
        defaultPaymentTerms: input.defaultPaymentTerms || 30,
        createdBy: actor.userId,
      };

      const vendor = await this.vendorRepo.create(repoInput, txContext);

      // 5. Emit audit (TRANSACTIONAL - same transaction)
      const auditEvent: AuditEvent = {
        eventType: 'finance.ap.vendor.created',
        entityId: vendor.id,
        entityUrn: `urn:finance:vendor:${vendor.id}`,
        actor: {
          userId: actor.userId,
          tenantId: actor.tenantId,
        },
        action: 'create',
        payload: {
          vendorCode: vendor.vendorCode,
          legalName: vendor.legalName,
          status: vendor.status,
        },
        correlationId: txContext.correlationId,
        timestamp: new Date(),
      };

      await this.auditPort.emitTransactional(auditEvent, txContext);

      return vendor;
    });
  }

  /**
   * Update vendor (draft only)
   * 
   * @param vendorId - Vendor ID
   * @param input - Update data
   * @param actor - Who is updating
   * @param expectedVersion - Expected version (optimistic locking)
   * @returns Updated vendor
   */
  async update(
    vendorId: string,
    input: UpdateVendorInput,
    actor: ActorContext,
    expectedVersion: number
  ): Promise<Vendor> {
    return this.vendorRepo.withTransaction(async (txContext) => {
      // 1. Fetch vendor with version check
      const vendor = await this.vendorRepo.findByIdForUpdate(
        vendorId,
        actor.tenantId,
        txContext
      );

      if (!vendor) {
        throw new VendorNotFoundError(vendorId);
      }

      // 2. Version check (concurrency control)
      if (vendor.version !== expectedVersion) {
        throw new Error(`Vendor was modified. Expected v${expectedVersion}, found v${vendor.version}`);
      }

      // 3. Status check (draft only)
      if (vendor.status !== 'draft') {
        throw new VendorNotInDraftError(vendor.status);
      }

      // 4. Validate updates
      if (input.country) validateCountry(input.country);
      if (input.currencyPreference) validateCurrency(input.currencyPreference);
      if (input.legalName) validateLegalName(input.legalName);

      // 5. Update vendor
      const repoInput: RepoUpdateInput = {
        tenantId: actor.tenantId,
        legalName: input.legalName,
        displayName: input.displayName,
        taxId: input.taxId,
        registrationNumber: input.registrationNumber,
        country: input.country,
        currencyPreference: input.currencyPreference,
        vendorCategory: input.vendorCategory,
        riskLevel: input.riskLevel,
        defaultPaymentTerms: input.defaultPaymentTerms,
      };

      const updated = await this.vendorRepo.update(vendorId, repoInput, txContext);

      // 6. Emit audit
      const auditEvent: AuditEvent = {
        eventType: 'finance.ap.vendor.updated',
        entityId: vendor.id,
        entityUrn: `urn:finance:vendor:${vendor.id}`,
        actor: {
          userId: actor.userId,
          tenantId: actor.tenantId,
        },
        action: 'update',
        payload: {
          before: {
            legalName: vendor.legalName,
            status: vendor.status,
          },
          after: {
            legalName: updated.legalName,
            status: updated.status,
          },
        },
        correlationId: txContext.correlationId,
        timestamp: new Date(),
      };

      await this.auditPort.emitTransactional(auditEvent, txContext);

      return updated;
    });
  }

  /**
   * Submit vendor for approval
   * 
   * @param vendorId - Vendor ID
   * @param actor - Who is submitting
   * @param expectedVersion - Expected version (optimistic locking)
   * @returns Updated vendor
   */
  async submit(
    vendorId: string,
    actor: ActorContext,
    expectedVersion: number
  ): Promise<Vendor> {
    return this.vendorRepo.withTransaction(async (txContext) => {
      // 1. Fetch vendor
      const vendor = await this.vendorRepo.findByIdForUpdate(
        vendorId,
        actor.tenantId,
        txContext
      );

      if (!vendor) {
        throw new VendorNotFoundError(vendorId);
      }

      // 2. Version check
      if (vendor.version !== expectedVersion) {
        throw new Error(`Vendor was modified. Expected v${expectedVersion}, found v${vendor.version}`);
      }

      // 3. State machine check
      if (!VendorStateMachine.canTransition(vendor.status, 'submit')) {
        throw new InvalidVendorStatusError(vendor.status, 'submit');
      }

      // 4. Update status to submitted
      const nextStatus = VendorStateMachine.getNextStatus(vendor.status, 'submit');
      const updated = await this.vendorRepo.updateStatus(
        vendorId,
        {
          tenantId: actor.tenantId,
          status: nextStatus,
        },
        txContext
      );

      // 5. Emit audit
      const auditEvent: AuditEvent = {
        eventType: 'finance.ap.vendor.submitted',
        entityId: vendor.id,
        entityUrn: `urn:finance:vendor:${vendor.id}`,
        actor: {
          userId: actor.userId,
          tenantId: actor.tenantId,
        },
        action: 'submit',
        payload: {
          fromStatus: vendor.status,
          toStatus: nextStatus,
        },
        correlationId: txContext.correlationId,
        timestamp: new Date(),
      };

      await this.auditPort.emitTransactional(auditEvent, txContext);

      return updated;
    });
  }

  /**
   * Get vendor by ID
   * 
   * @param vendorId - Vendor ID
   * @param actor - Actor context
   * @returns Vendor or null
   */
  async getById(vendorId: string, actor: ActorContext): Promise<Vendor | null> {
    return this.vendorRepo.findById(vendorId, actor.tenantId);
  }

  /**
   * List vendors with filters
   * 
   * @param filters - Query filters
   * @param actor - Actor context
   * @returns Vendors and total count
   */
  async list(
    filters: {
      status?: string | string[];
      vendorCategory?: string;
      riskLevel?: string;
      isBlacklisted?: boolean;
      search?: string;
      limit?: number;
      offset?: number;
    },
    actor: ActorContext
  ): Promise<{ vendors: Vendor[]; total: number }> {
    return this.vendorRepo.list({
      tenantId: actor.tenantId,
      status: filters.status as any,
      vendorCategory: filters.vendorCategory,
      riskLevel: filters.riskLevel as any,
      isBlacklisted: filters.isBlacklisted,
      search: filters.search,
      limit: filters.limit,
      offset: filters.offset,
    });
  }
}
