/**
 * Vendor Repository - SQL Adapter (PostgreSQL)
 * 
 * Implements VendorRepositoryPort for production use.
 * 
 * Key Features:
 * - Optimistic locking via version column
 * - RLS tenant isolation (set via session)
 * - Row-level locking for updates (SELECT FOR UPDATE)
 * - SoD enforcement via database constraints
 */

import type { PoolClient, Pool } from 'pg';
import type {
  VendorRepositoryPort,
  Vendor,
  VendorBankAccount,
  CreateVendorInput,
  UpdateVendorInput,
  UpdateVendorStatusInput,
  CreateBankAccountInput,
  RequestBankAccountChangeInput,
  ApproveBankAccountChangeInput,
  VendorQueryFilters,
  TransactionContext,
  VendorStatus,
  RiskLevel,
} from '@aibos/kernel-core';
import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// 1. SQL QUERIES
// ============================================================================

const SQL = {
  // Create vendor (vendor_code generated by database function)
  CREATE_VENDOR: `
    INSERT INTO ap.vendors (
      id, tenant_id, vendor_code, legal_name, display_name,
      tax_id, registration_number, country, currency_preference,
      vendor_category, risk_level, status, default_payment_terms,
      is_blacklisted, duplicate_bank_account_flag, high_risk_category_flag,
      created_by, version, created_at, updated_at
    ) VALUES (
      $1, $2, ap.generate_vendor_code($2), $3, $4, $5, $6, $7, $8, $9, $10, $11, $12,
      FALSE, FALSE, FALSE, $13, 1, NOW(), NOW()
    )
    RETURNING *
  `,

  // Find vendor by ID
  FIND_VENDOR_BY_ID: `
    SELECT * FROM ap.vendors
    WHERE id = $1 AND tenant_id = $2
  `,

  // Find vendor by ID with lock
  FIND_VENDOR_BY_ID_FOR_UPDATE: `
    SELECT * FROM ap.vendors
    WHERE id = $1 AND tenant_id = $2
    FOR UPDATE
  `,

  // Find vendor by code
  FIND_VENDOR_BY_CODE: `
    SELECT * FROM ap.vendors
    WHERE vendor_code = $1 AND tenant_id = $2
  `,

  // Update vendor (draft only) - OPTIMIZED: Added version increment
  UPDATE_VENDOR: `
    UPDATE ap.vendors
    SET legal_name = COALESCE($1, legal_name),
        display_name = COALESCE($2, display_name),
        tax_id = COALESCE($3, tax_id),
        registration_number = COALESCE($4, registration_number),
        country = COALESCE($5, country),
        currency_preference = COALESCE($6, currency_preference),
        vendor_category = COALESCE($7, vendor_category),
        risk_level = COALESCE($8, risk_level),
        default_payment_terms = COALESCE($9, default_payment_terms),
        version = version + 1,
        updated_at = NOW()
    WHERE id = $10 AND tenant_id = $11 AND status = 'draft'
    RETURNING *
  `,

  // Update vendor status - OPTIMIZED: Added version increment
  UPDATE_VENDOR_STATUS: `
    UPDATE ap.vendors
    SET status = $1,
        approved_by = COALESCE($2, approved_by),
        approved_at = COALESCE($3, approved_at),
        version = version + 1,
        updated_at = NOW()
    WHERE id = $4 AND tenant_id = $5
    RETURNING *
  `,

  // Add bank account
  ADD_BANK_ACCOUNT: `
    INSERT INTO ap.vendor_bank_accounts (
      id, vendor_id, tenant_id, bank_name, account_number,
      account_name, routing_number, swift_code, iban, currency,
      is_primary, is_active, created_by, version, created_at, updated_at
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, TRUE, $12, 1, NOW(), NOW()
    )
    RETURNING *
  `,

  // Find bank account by ID
  FIND_BANK_ACCOUNT_BY_ID: `
    SELECT * FROM ap.vendor_bank_accounts
    WHERE id = $1 AND tenant_id = $2
  `,

  // Find bank account by ID with lock
  FIND_BANK_ACCOUNT_BY_ID_FOR_UPDATE: `
    SELECT * FROM ap.vendor_bank_accounts
    WHERE id = $1 AND tenant_id = $2
    FOR UPDATE
  `,

  // List bank accounts for vendor
  LIST_BANK_ACCOUNTS: `
    SELECT * FROM ap.vendor_bank_accounts
    WHERE vendor_id = $1 AND tenant_id = $2
    ORDER BY is_primary DESC, created_at ASC
  `,

  // Request bank account change
  REQUEST_BANK_ACCOUNT_CHANGE: `
    UPDATE ap.vendor_bank_accounts
    SET bank_name = COALESCE($1, bank_name),
        account_number = COALESCE($2, account_number),
        account_name = COALESCE($3, account_name),
        routing_number = COALESCE($4, routing_number),
        swift_code = COALESCE($5, swift_code),
        iban = COALESCE($6, iban),
        currency = COALESCE($7, currency),
        change_request_status = 'pending_approval',
        change_requested_by = $8,
        change_requested_at = NOW(),
        updated_at = NOW()
    WHERE id = $9 AND tenant_id = $10
    RETURNING *
  `,

  // Approve bank account change
  APPROVE_BANK_ACCOUNT_CHANGE: `
    UPDATE ap.vendor_bank_accounts
    SET change_request_status = 'approved',
        change_approved_by = $1,
        change_approved_at = $2,
        updated_at = NOW()
    WHERE id = $3 AND tenant_id = $4
      AND change_request_status = 'pending_approval'
    RETURNING *
  `,

  // Detect duplicate bank accounts
  DETECT_DUPLICATE_BANK_ACCOUNTS: `
    SELECT DISTINCT vba.vendor_id
    FROM ap.vendor_bank_accounts vba
    WHERE vba.tenant_id = $1
      AND vba.account_number = $2
      AND ($3 IS NULL OR vba.routing_number = $3)
      AND ($4 IS NULL OR vba.vendor_id != $4)
  `,
};

// ============================================================================
// 2. ROW MAPPERS
// ============================================================================

function mapVendorRow(row: Record<string, unknown>): Vendor {
  return {
    id: row.id as string,
    tenantId: row.tenant_id as string,
    vendorCode: row.vendor_code as string,
    legalName: row.legal_name as string,
    displayName: row.display_name as string | undefined,
    taxId: row.tax_id as string | undefined,
    registrationNumber: row.registration_number as string | undefined,
    country: row.country as string,
    currencyPreference: row.currency_preference as string,
    vendorCategory: row.vendor_category as string | undefined,
    riskLevel: (row.risk_level as RiskLevel) || 'LOW',
    status: row.status as VendorStatus,
    defaultPaymentTerms: (row.default_payment_terms as number) || 30,
    defaultBankAccountId: row.default_bank_account_id as string | undefined,
    isBlacklisted: (row.is_blacklisted as boolean) || false,
    duplicateBankAccountFlag: (row.duplicate_bank_account_flag as boolean) || false,
    highRiskCategoryFlag: (row.high_risk_category_flag as boolean) || false,
    createdBy: row.created_by as string,
    createdAt: new Date(row.created_at as string),
    approvedBy: row.approved_by as string | undefined,
    approvedAt: row.approved_at ? new Date(row.approved_at as string) : undefined,
    version: row.version as number,
    updatedAt: new Date(row.updated_at as string),
  };
}

function mapBankAccountRow(row: Record<string, unknown>): VendorBankAccount {
  return {
    id: row.id as string,
    vendorId: row.vendor_id as string,
    tenantId: row.tenant_id as string,
    bankName: row.bank_name as string,
    accountNumber: row.account_number as string,
    accountName: row.account_name as string,
    routingNumber: row.routing_number as string | undefined,
    swiftCode: row.swift_code as string | undefined,
    iban: row.iban as string | undefined,
    currency: row.currency as string,
    isPrimary: (row.is_primary as boolean) || false,
    isActive: (row.is_active as boolean) || true,
    changeRequestStatus: row.change_request_status as 'pending_approval' | 'approved' | 'rejected' | undefined,
    changeRequestedBy: row.change_requested_by as string | undefined,
    changeRequestedAt: row.change_requested_at ? new Date(row.change_requested_at as string) : undefined,
    changeApprovedBy: row.change_approved_by as string | undefined,
    changeApprovedAt: row.change_approved_at ? new Date(row.change_approved_at as string) : undefined,
    createdBy: row.created_by as string,
    createdAt: new Date(row.created_at as string),
    version: row.version as number,
    updatedAt: new Date(row.updated_at as string),
  };
}

// ============================================================================
// 3. SQL ADAPTER
// ============================================================================

export class SqlVendorRepository implements VendorRepositoryPort {
  constructor(private pool: Pool) { }

  async withTransaction<T>(
    callback: (txContext: TransactionContext) => Promise<T>
  ): Promise<T> {
    const client = await this.pool.connect();
    const correlationId = uuidv4();

    try {
      await client.query('BEGIN');

      const txContext: TransactionContext = {
        tx: client,
        correlationId,
      };

      const result = await callback(txContext);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async create(
    input: CreateVendorInput,
    txContext: TransactionContext
  ): Promise<Vendor> {
    const client = txContext.tx as PoolClient;
    const id = uuidv4();

    const result = await client.query(SQL.CREATE_VENDOR, [
      id,
      input.tenantId,
      input.legalName,
      input.displayName || null,
      input.taxId || null,
      input.registrationNumber || null,
      input.country,
      input.currencyPreference,
      input.vendorCategory || null,
      input.riskLevel || 'LOW',
      'draft',
      input.defaultPaymentTerms || 30,
      input.createdBy,
    ]);

    return mapVendorRow(result.rows[0]);
  }

  async findById(id: string, tenantId: string): Promise<Vendor | null> {
    const result = await this.pool.query(SQL.FIND_VENDOR_BY_ID, [id, tenantId]);
    return result.rows[0] ? mapVendorRow(result.rows[0]) : null;
  }

  async findByIdForUpdate(
    id: string,
    tenantId: string,
    txContext: TransactionContext
  ): Promise<Vendor | null> {
    const client = txContext.tx as PoolClient;
    const result = await client.query(SQL.FIND_VENDOR_BY_ID_FOR_UPDATE, [id, tenantId]);
    return result.rows[0] ? mapVendorRow(result.rows[0]) : null;
  }

  async findByCode(vendorCode: string, tenantId: string): Promise<Vendor | null> {
    const result = await this.pool.query(SQL.FIND_VENDOR_BY_CODE, [vendorCode, tenantId]);
    return result.rows[0] ? mapVendorRow(result.rows[0]) : null;
  }

  async update(
    id: string,
    input: UpdateVendorInput,
    txContext: TransactionContext
  ): Promise<Vendor> {
    const client = txContext.tx as PoolClient;

    const result = await client.query(SQL.UPDATE_VENDOR, [
      input.legalName || null,
      input.displayName || null,
      input.taxId || null,
      input.registrationNumber || null,
      input.country || null,
      input.currencyPreference || null,
      input.vendorCategory || null,
      input.riskLevel || null,
      input.defaultPaymentTerms || null,
      id,
      input.tenantId,
    ]);

    if (result.rows.length === 0) {
      // Throw generic error - services will convert to domain errors
      throw new Error(`Vendor not found or not in draft status: ${id}`);
    }

    return mapVendorRow(result.rows[0]);
  }

  async updateStatus(
    id: string,
    input: UpdateVendorStatusInput,
    txContext: TransactionContext
  ): Promise<Vendor> {
    const client = txContext.tx as PoolClient;

    const result = await client.query(SQL.UPDATE_VENDOR_STATUS, [
      input.status,
      input.approvedBy || null,
      input.approvedAt || null,
      id,
      input.tenantId,
    ]);

    if (result.rows.length === 0) {
      // Throw generic error - services will convert to domain errors
      throw new Error(`Vendor not found: ${id}`);
    }

    return mapVendorRow(result.rows[0]);
  }

  async list(filters: VendorQueryFilters): Promise<{ vendors: Vendor[]; total: number }> {
    const conditions: string[] = ['tenant_id = $1'];
    const values: unknown[] = [filters.tenantId];
    let paramIndex = 2;

    if (filters.status) {
      if (Array.isArray(filters.status)) {
        conditions.push(`status = ANY($${paramIndex})`);
        values.push(filters.status);
      } else {
        conditions.push(`status = $${paramIndex}`);
        values.push(filters.status);
      }
      paramIndex++;
    }

    if (filters.vendorCategory) {
      conditions.push(`vendor_category = $${paramIndex}`);
      values.push(filters.vendorCategory);
      paramIndex++;
    }

    if (filters.riskLevel) {
      conditions.push(`risk_level = $${paramIndex}`);
      values.push(filters.riskLevel);
      paramIndex++;
    }

    if (filters.isBlacklisted !== undefined) {
      conditions.push(`is_blacklisted = $${paramIndex}`);
      values.push(filters.isBlacklisted);
      paramIndex++;
    }

    if (filters.search) {
      conditions.push(`(
        legal_name ILIKE $${paramIndex} OR
        display_name ILIKE $${paramIndex} OR
        vendor_code ILIKE $${paramIndex}
      )`);
      values.push(`%${filters.search}%`);
      paramIndex++;
    }

    const whereClause = conditions.join(' AND ');

    // Get vendors with pagination and total count in single query (optimized)
    const limit = filters.limit || 50;
    const offset = filters.offset || 0;
    values.push(limit, offset);

    const result = await this.pool.query(
      `SELECT 
        *,
        COUNT(*) OVER() as total
      FROM ap.vendors 
      WHERE ${whereClause} 
      ORDER BY created_at DESC 
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      values
    );

    const total = result.rows.length > 0 
      ? parseInt(result.rows[0].total as string, 10) 
      : 0;

    return {
      vendors: result.rows.map(mapVendorRow),
      total,
    };
  }

  async addBankAccount(
    input: CreateBankAccountInput,
    txContext: TransactionContext
  ): Promise<VendorBankAccount> {
    const client = txContext.tx as PoolClient;
    const id = uuidv4();

    const result = await client.query(SQL.ADD_BANK_ACCOUNT, [
      id,
      input.vendorId,
      input.tenantId,
      input.bankName,
      input.accountNumber,
      input.accountName,
      input.routingNumber || null,
      input.swiftCode || null,
      input.iban || null,
      input.currency,
      input.isPrimary || false,
      input.createdBy,
    ]);

    return mapBankAccountRow(result.rows[0]);
  }

  async findBankAccountById(id: string, tenantId: string): Promise<VendorBankAccount | null> {
    const result = await this.pool.query(SQL.FIND_BANK_ACCOUNT_BY_ID, [id, tenantId]);
    return result.rows[0] ? mapBankAccountRow(result.rows[0]) : null;
  }

  async findBankAccountByIdForUpdate(
    id: string,
    tenantId: string,
    txContext: TransactionContext
  ): Promise<VendorBankAccount | null> {
    const client = txContext.tx as PoolClient;
    const result = await client.query(SQL.FIND_BANK_ACCOUNT_BY_ID_FOR_UPDATE, [id, tenantId]);
    return result.rows[0] ? mapBankAccountRow(result.rows[0]) : null;
  }

  async listBankAccounts(vendorId: string, tenantId: string): Promise<VendorBankAccount[]> {
    const result = await this.pool.query(SQL.LIST_BANK_ACCOUNTS, [vendorId, tenantId]);
    return result.rows.map(mapBankAccountRow);
  }

  async requestBankAccountChange(
    input: RequestBankAccountChangeInput,
    txContext: TransactionContext
  ): Promise<VendorBankAccount> {
    const client = txContext.tx as PoolClient;

    const result = await client.query(SQL.REQUEST_BANK_ACCOUNT_CHANGE, [
      input.bankName || null,
      input.accountNumber || null,
      input.accountName || null,
      input.routingNumber || null,
      input.swiftCode || null,
      input.iban || null,
      input.currency || null,
      input.requestedBy,
      input.bankAccountId,
      input.tenantId,
    ]);

    if (result.rows.length === 0) {
      // Throw generic error - services will convert to domain errors
      throw new Error(`Bank account not found: ${input.bankAccountId}`);
    }

    return mapBankAccountRow(result.rows[0]);
  }

  async approveBankAccountChange(
    input: ApproveBankAccountChangeInput,
    txContext: TransactionContext
  ): Promise<VendorBankAccount> {
    const client = txContext.tx as PoolClient;

    const result = await client.query(SQL.APPROVE_BANK_ACCOUNT_CHANGE, [
      input.approvedBy,
      input.approvedAt,
      input.bankAccountId,
      input.tenantId,
    ]);

    if (result.rows.length === 0) {
      // Throw generic error - services will convert to domain errors
      throw new Error(`Bank account change request not found or already processed: ${input.bankAccountId}`);
    }

    return mapBankAccountRow(result.rows[0]);
  }

  async detectDuplicateBankAccounts(
    accountNumber: string,
    routingNumber: string | undefined,
    tenantId: string,
    excludeVendorId?: string
  ): Promise<string[]> {
    const result = await this.pool.query(SQL.DETECT_DUPLICATE_BANK_ACCOUNTS, [
      tenantId,
      accountNumber,
      routingNumber || null,
      excludeVendorId || null,
    ]);

    return result.rows.map(row => row.vendor_id as string);
  }
}

/**
 * Factory function to create SQL vendor repository
 */
export function createSqlVendorRepository(pool: Pool): VendorRepositoryPort {
  return new SqlVendorRepository(pool);
}
