#!/usr/bin/env tsx
/**
 * TOOL_24: Generate Canon Page Wrappers
 * 
 * Generates thin wrapper files from canon-pages registry.
 * Ensures consistency and prevents drift.
 * 
 * Features:
 * - Registry-driven generation
 * - Consistent pattern
 * - Type-safe
 * - Dry-run mode
 * 
 * Usage:
 *   npx tsx canon/D-Operations/D-TOOL/TOOL_24_GenerateCanonPageWrapper.ts
 *   npx tsx canon/D-Operations/D-TOOL/TOOL_24_GenerateCanonPageWrapper.ts --execute
 */

import { existsSync, writeFileSync, mkdirSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { CANON_PAGES, type CanonPageInfo } from '../../registry/canon-pages';

// Note: In Next.js, path aliases will be configured in tsconfig.json:
// "@/*": ["./*"] or "@/canon/*": ["./canon/*"]

const ROOT = process.cwd();
const DRY_RUN = !process.argv.includes('--execute');

/**
 * Generate thin wrapper content from page info
 */
function generateWrapper(pageInfo: CanonPageInfo): string {
  return `// app/canon/${pageInfo.domain.toLowerCase()}/${pageInfo.slug}/page.tsx
// Auto-generated by TOOL_24 - DO NOT EDIT MANUALLY
// Source: canon/registry/canon-pages.ts
// 
// To regenerate: npx tsx canon/D-Operations/D-TOOL/TOOL_24_GenerateCanonPageWrapper.ts --execute

import type { Metadata } from 'next';
import { CanonPageShell } from '@/app/components/canon/CanonPageShell';
import { getCanonPageInfo } from '@/canon/registry/canon-pages';
import CanonContent from '@/canon-pages/${pageInfo.mdxPath}';

// Get page info from registry (type-safe)
const pageInfo = getCanonPageInfo('${pageInfo.canonId}');
if (!pageInfo) {
  throw new Error(\`Canon page ${pageInfo.canonId} not found in registry\`);
}

// Generate metadata from registry
export const metadata: Metadata = {
  title: \`\${pageInfo.canonId} ‚Äì \${pageInfo.title}\`,
  description: pageInfo.description,
};

// Thin wrapper - no business logic
export default function CanonPage() {
  return (
    <CanonPageShell pageInfo={pageInfo}>
      <CanonContent />
    </CanonPageShell>
  );
}
`;
}

/**
 * Check if wrapper already exists and is auto-generated
 */
function isAutoGenerated(filePath: string): boolean {
  if (!existsSync(filePath)) return false;
  
  const content = readFileSync(filePath, 'utf-8');
  return content.includes('Auto-generated by TOOL_24');
}

async function main() {
  console.log('üöÄ TOOL_24: Generate Canon Page Wrappers\n');
  
  if (DRY_RUN) {
    console.log('‚ö†Ô∏è  DRY RUN MODE - No files will be generated');
    console.log('   Use --execute flag to generate wrappers\n');
  } else {
    console.log('‚úÖ EXECUTE MODE - Wrapper files will be generated\n');
  }
  
  const results: Array<{
    canonId: string;
    path: string;
    status: 'generated' | 'skipped' | 'exists' | 'error';
    error?: string;
  }> = [];
  
  for (const [canonId, pageInfo] of Object.entries(CANON_PAGES)) {
    const wrapperPath = join(
      ROOT,
      'app',
      'canon',
      pageInfo.domain.toLowerCase(),
      pageInfo.slug,
      'page.tsx'
    );
    
    // Check if file exists
    if (existsSync(wrapperPath)) {
      if (isAutoGenerated(wrapperPath)) {
        console.log(`  ${canonId}: ${wrapperPath}`);
        console.log(`    ‚ö†Ô∏è  Already exists (auto-generated)`);
        if (!DRY_RUN) {
          // Regenerate to ensure consistency
          try {
            mkdirSync(dirname(wrapperPath), { recursive: true });
            writeFileSync(wrapperPath, generateWrapper(pageInfo), 'utf-8');
            console.log(`    ‚úÖ Regenerated`);
            results.push({ canonId, path: wrapperPath, status: 'generated' });
          } catch (error: any) {
            console.log(`    ‚ùå Error: ${error.message}`);
            results.push({
              canonId,
              path: wrapperPath,
              status: 'error',
              error: error.message,
            });
          }
        } else {
          results.push({ canonId, path: wrapperPath, status: 'exists' });
        }
      } else {
        console.log(`  ${canonId}: ${wrapperPath}`);
        console.log(`    ‚ö†Ô∏è  File exists but not auto-generated - SKIPPED`);
        console.log(`    üí° Manually review and migrate to thin wrapper pattern`);
        results.push({ canonId, path: wrapperPath, status: 'skipped' });
      }
    } else {
      console.log(`  ${canonId}: ${wrapperPath}`);
      if (!DRY_RUN) {
        try {
          mkdirSync(dirname(wrapperPath), { recursive: true });
          writeFileSync(wrapperPath, generateWrapper(pageInfo), 'utf-8');
          console.log(`    ‚úÖ Generated`);
          results.push({ canonId, path: wrapperPath, status: 'generated' });
        } catch (error: any) {
          console.log(`    ‚ùå Error: ${error.message}`);
          results.push({
            canonId,
            path: wrapperPath,
            status: 'error',
            error: error.message,
          });
        }
      } else {
        console.log(`    üí° Would generate`);
        results.push({ canonId, path: wrapperPath, status: 'generated' });
      }
    }
    console.log('');
  }
  
  // Summary
  const generated = results.filter((r) => r.status === 'generated').length;
  const skipped = results.filter((r) => r.status === 'skipped').length;
  const exists = results.filter((r) => r.status === 'exists').length;
  const errors = results.filter((r) => r.status === 'error').length;
  
  console.log('='.repeat(60));
  console.log('üìä Summary:');
  console.log(`   ‚úÖ ${DRY_RUN ? 'Would generate' : 'Generated'}: ${generated} wrappers`);
  if (skipped > 0) {
    console.log(`   ‚ö†Ô∏è  Skipped (manual files): ${skipped} wrappers`);
  }
  if (exists > 0) {
    console.log(`   ‚ÑπÔ∏è  Already exists: ${exists} wrappers`);
  }
  if (errors > 0) {
    console.log(`   ‚ùå Errors: ${errors} wrappers`);
  }
  console.log(`   üìÑ Total pages in registry: ${Object.keys(CANON_PAGES).length}`);
  
  if (DRY_RUN) {
    console.log('\nüí° To generate wrappers, run with --execute flag:');
    console.log('   npx tsx canon/D-Operations/D-TOOL/TOOL_24_GenerateCanonPageWrapper.ts --execute');
  } else {
    console.log('\n‚úÖ Wrapper generation completed!');
    console.log('üí° Next steps:');
    console.log('   1. Verify generated wrappers');
    console.log('   2. Ensure MDX files exist in canon-pages/');
    console.log('   3. Test routes in browser');
    console.log('   4. Run TOOL_18 to verify compliance');
  }
}

main().catch(console.error);
